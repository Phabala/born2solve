**닉네임**: kchoo

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 지형 이동

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/62050

**오늘의 메모(선택)**: 

프림 알고리즘 변형으로 높이차 height 초과 시 사다리 비용을 더해 최소 총 이동 비용 계산

**코드(선택)**: 

```c++
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

struct Pos {
  int r;
  int c;
  int heightDiff;
  bool operator<(const Pos &p) const {
    return heightDiff > p.heightDiff;
  }
};

int dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};
bool visited[301][301];

bool isValid(int nr, int nc, int rows, int cols) {
  return nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc];
}

int solution(vector<vector<int>> land, int height) {
  int totalCost = 0;
  int rows = land.size(), cols = land[0].size();

  priority_queue<Pos> pq;
  pq.push({0, 0, 0});

  while (!pq.empty()) {
    Pos current = pq.top();
    pq.pop();

    if (visited[current.r][current.c])
      continue;
    totalCost += current.heightDiff;

    for (int i = 0; i < 4; i++) {
      int nr = current.r + dy[i], nc = current.c + dx[i];
      if (isValid(nr, nc, rows, cols)) {
        int diff = abs(land[current.r][current.c] - land[nr][nc]);
        if (diff > height)
          pq.push({nr, nc, diff});
        else
          pq.push({nr, nc, 0});
      }
    }
    visited[current.r][current.c] = true;
  }

  return totalCost;
}

```
