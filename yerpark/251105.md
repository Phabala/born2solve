**닉네임**: yerpark  

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 1916 문제

**문제 링크**: https://www.acmicpc.net/problem/1916

**오늘의 메모(선택)**: 

**코드(선택)**:

```python3
#다익스트라 알고리즘을 활용
    #우선순위큐로 구현
    #기본적인건 bfs인데, 비용을 계산하는 배열을 가지고 그 배열 원소값을 갱신하며 탐색

import sys, heapq

class   graph():
    def __init__(self, n):
        self.adjList = { i: [] for i in range(1, n + 1) }

    def makeConnection(self, start, end, cost):
        self.adjList[start].append((end, cost))
    
def     dijkstra(myGraph, startCity, destCity, n):
    
    if (startCity == destCity):
        return (0)
    
    costs = [sys.maxsize] * (n + 1)
    costs[startCity] = 0
    pq = []

    heapq.heappush(pq, (0, startCity))

    while (pq):
        curCost, curCity = heapq.heappop(pq)
        
        if (costs[curCity] < curCost):
            continue

        for nextCity, nextCityCost in myGraph.adjList[curCity]:
            nextCost = curCost + nextCityCost
            if (costs[nextCity] <= nextCost):
                continue
            costs[nextCity] = nextCost
            heapq.heappush(pq, (nextCost, nextCity))
    
    return (costs[destCity])

if __name__ == "__main__":
    n = int(sys.stdin.readline().strip())
    m = int(sys.stdin.readline().strip())

    myGraph = graph(n)

    for _ in range(m):
        start, end, cost = map(int, sys.stdin.readline().split())
        myGraph.makeConnection(start, end, cost)

    startCity, destCity = map(int, sys.stdin.readline().split())

    print(dijkstra(myGraph, startCity, destCity, n))






\```
