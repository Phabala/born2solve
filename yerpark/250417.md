**닉네임**: yerpark

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 2563 / 색종이 문제

**문제 링크**: [https://www.acmicpc.net/problem/1000](https://www.acmicpc.net/problem/2563)

**오늘의 메모(선택)**: 날 막았던 문제.. 이상한 방법으로 풀려다가 다 실패하고 gpt한테 힌트를 달라고 했다. 
그 힌트를 받고 문제가 너무 쉽게 풀려 허무 했다. 

원래 접근 방식 ) 색종이가 겹쳤는지 안겹쳤는지 판단하고, 겹쳤으면 전체 크기에서 빼고 이런 방법을 처음에 생각했었다.
이 접근방식의 문제는 3개 이상이 겹쳤을 때 어떻게 해야할지, 3개 이상 4개 이상 5개 이상의 경우에 대한 처리가 어려워보였다. 
그래서 이 문제를 버렸었는데, gpt가 해당 칸이 색종이로 덮였는지 안덮였는지를 판단하는 2차원 배열을 만들어보라고 했다.
그 힌트를 보자마자 허무해졌다.. 너무 쉬운 해결책이었기 때문이다.. 왜 이런 해결책을 진작 떠올리지 못했을까.. 

색종이 전체 크기의 2차원 배열을 만들고 arr[100][100] 해당 칸이 색종이로 덮였으면 값을 1로 바꾸는 식으로 진행했다.
나중에 2차원 배열을 돌면서 1인 경우 크기를 1씩 증가시키는 방법으로 영역의 넓이를 구했다. 

사실 겹쳤는지 여부가 중요한게 아니라 해당 영역이 단순히 덮였는지 안덮였는지를 판단하면 된다는 것을 알았다면 좋았을텐데.. 

**코드(선택)**:

```c++
#include <iostream>

int    main(void)
{
    int    paper_num;
    int    arr[100][100]; // 색종이가 덮어졌는지 안덮여졌는지 판단하는 정보값
                            // 있으면 1 없으면 0
    int    start_x, start_y;
    int    sum;
    
    for (int i = 0; i < 100; i++)
    {
        for (int j = 0; j < 100; j++)
        {
            arr[i][j] = 0;
        }
    }
    std::cin >> paper_num;
    for (int i = 0; i < paper_num; i++)
    {
        std::cin >> start_x >> start_y;
        for (int row = 0; row < 10; row++)
        {
            for (int col = 0; col < 10; col++)
                arr[start_y + row][start_x + col] = 1;
        }
    }
    sum = 0;
    for (int i = 0; i < 100; i++)
    {
        for (int j = 0; j < 100; j++)
        {
            if (arr[i][j] == 1)
                sum++;
        }
    }
    std::cout << sum;
    
    return 0;
}
\```
