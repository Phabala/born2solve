**닉네임**: kyouhele

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 리코쳇로봇

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/169199

**오늘의 메모(선택)**: 히히 성공

**코드(선택)**:

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int x, y;
    int moves;
} Node;

int up(char* board[], int *_x, int *_y);
int down(char* board[], int *_x, int *_y);
int left(char* board[], int *_x, int *_y);
int right(char* board[], int *_x, int *_y);
void getpos(char **board, int *_x, int *_y);
int do_bfs(char** board, int board_len);
int inRange(int x, int y, int n, int m);

int solution(const char* _board[], size_t board_len)
{
    char **board = calloc(board_len+1,sizeof(char*));
    board[board_len] = 0;
    for (int i = 0; i < board_len; i++)
	{
        board[i] = calloc(strlen(_board[i])+1, sizeof(char));
        for (int j = 0; j < strlen(_board[i]); j++)
            board[i][j] = _board[i][j];
    }

    int cnt = do_bfs(board, board_len);

    for (int i = 0; i < board_len; i++)
        free(board[i]);
    free(board);

    return cnt;
}

int do_bfs(char *board[], int board_len)
{
    int n = board_len, m = strlen(board[0]), _x, _y;
 
	getpos(board, &_x, &_y);
    if (_x == -1) return -1;

    bool visited[101][101] = {false};
    visited[_x][_y] = true;

    Node *queue = calloc(n * m, sizeof(Node));
    int front = 0, rear = 0;
    queue[rear++] = (Node){_x, _y, 0};

    while (front < rear)
    {
        Node cur = queue[front++];

        if (board[cur.x][cur.y] == 'G') {
            free(queue);
            return cur.moves;
        }

        for (int d = 0; d < 4; d++) {
            int nx = cur.x, ny = cur.y;
            int res = 0;

            if (d == 0) res = up(board, &nx, &ny);
            else if (d == 1) res = down(board, &nx, &ny);
            else if (d == 2) res = left(board, &nx, &ny);
            else if (d == 3) res = right(board, &nx, &ny);

            if (res == -1)
			{
                free(queue);
                return cur.moves + 1;
            }
			else if (res == 0)
                continue;
			else
			{
				if (inRange(nx, ny, n, m) && !visited[nx][ny])
				{
                    visited[nx][ny] = true;
                    queue[rear++] = (Node){nx, ny, cur.moves + 1};
                }
            }
        }
    }

    free(queue);
    return -1;
}

void getpos(char **board, int *x, int *y)
{
    for (int i = 0; board[i]; i++)
	{
        for (int j = 0; board[i][j]; j++)
		{
            if (board[i][j] == 'R')
			{
                *x = i;
                *y = j;
                return;
            }
        }
    }
    *x = *y = -1;
}

int inRange(int x, int y, int n, int m)
{
    return x >= 0 && x < n && y >= 0 && y < m;
}

int up(char* board[], int *_x, int *_y)
{
    int x = *_x, y = *_y, tmp = x;
    while (x - 1 >= 0 && board[x - 1][y] != 'D')
        x--;

	if (x == tmp) return 0;
	
	*_x = x;

	if (board[x][y] == 'G') return -1;
    return 1;
}

int down(char* board[], int *_x, int *_y)
{
    int x = *_x, y = *_y, tmp = x, n = 0;
    while (board[n]) n++;
    while (x + 1 < n && board[x + 1][y] != 'D')
		x++;

    if (x == tmp) return 0;
    
	*_x = x;
    
	if (board[x][y] == 'G') return -1;
    return 1;
}

int left(char* board[], int *_x, int *_y)
{
    int x = *_x, y = *_y, tmp = y;
    while (y - 1 >= 0 && board[x][y - 1] != 'D')
        y--;
    
    if (y == tmp) return 0;
    
	*_y = y;
    
	if (board[x][y] == 'G') return -1;
    return 1;
}

int right(char* board[], int *_x, int *_y)
{
    int x = *_x, y = *_y, tmp = y;
    int m = strlen(board[0]);
    while (y + 1 < m && board[x][y + 1] != 'D')
        y++;
    
    if (y == tmp) return 0;
    *_y = y;
    if (board[x][y] == 'G') return -1;
    return 1;
}

```
