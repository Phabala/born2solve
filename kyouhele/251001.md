**닉네임**: kyouhele

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 합승택시요금

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/72413

**오늘의 메모(선택)**: gpt멍청이

**코드(선택)**:

```c
#include <string>
#include <vector>
#include <queue>
const int INF = 1e9;
using namespace std;

vector<int> dijk(int start, int n, vector<vector<pair<int,int>>>& graph)
{
    vector<int> dist(n+1, INF);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    
    dist[start] = 0;
    pq.push ({0,start});
    
    while (!pq.empty())
    {
        auto [cost, u] = pq.top();
        pq.pop();
        if (cost > dist[u])
            continue ;
        for (auto [v,w] : graph[u])
        {
            if (dist[v] > cost + w)
            {
                dist[v] = cost + w;
                pq.push({dist[v],v});
            }
        }
    }
    return dist;
}
int solution(int n, int s, int a, int b, vector<vector<int>> fares)
{
    vector<vector<pair<int,int>>> graph(n+1);
    for (auto &f : fares) {
        int u = f[0], v = f[1], w = f[2];
        graph[u].push_back({v, w});
        graph[v].push_back({u, w});
    }

    vector<int> distS = dijk(s, n, graph);
    vector<int> distA = dijk(a, n, graph);
    vector<int> distB = dijk(b, n, graph);

    int answer = INF;
    for (int k = 1; k <= n; k++)
    {
        if (distS[k] == INF || distA[k] == INF || distB[k] == INF)
            continue;
        long long total = (long long)distS[k] + distA[k] + distB[k];
        answer = min(answer, (int)total);
    }
    return answer;
}


```
