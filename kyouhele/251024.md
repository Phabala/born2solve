**닉네임**: kyouhele

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 

**문제 링크**: https://school.programmers.co.kr/skill-assessments/problem-solving/report

**오늘의 메모(선택)**: 오 오랜만에 너무 재밌었다! 재귀파티파티 트리순회 알고리즘 공부하기 + 람다식 재밌어 히히

**코드(선택)**:

```c++

#include <string>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

typedef struct node
{
    int x, depth, idx;
    node *left, *right;
} node ;

node* init_tree(vector<vector<int>> nodeinfo, vector<node> &_tree);
void insert_node(node* high, node* low);
void pre(node *root, vector<int> &tree);
void post(node *root, vector<int> &tree);

vector<vector<int>> solution(vector<vector<int>> nodeinfo) {
    vector<vector<int>> answer(2);
    vector<node> tree;
    
    //트리 구조 만들기
    node *root = init_tree(nodeinfo, tree);
    
    pre(root, answer[0]);      //전위순회 _preorder
    post(root, answer[1]);     //후위순회 _postorder
    
    return answer;
}

node* init_tree(vector<vector<int>> nodeinfo, vector<node> &tree)
{
    //init & fill info
    for (int i = 0; i < nodeinfo.size(); i++)
        tree.push_back({nodeinfo[i][0], nodeinfo[i][1], i+1, NULL, NULL});
    
    //sort Nodes
    sort(tree.begin(), tree.end(), [](const node &a, const node &b)
         {
             if (a.depth == b.depth)
                 return (a.x < b.x);
             return (a.depth > b.depth);
         });
    
    node *root = &tree[0]; 
    
    // draw lines between nodes;
    for (int i = 1; i < nodeinfo.size(); i++)
        insert_node(root, &tree[i]);
    return root;
}

void insert_node(node* high, node* low)
{
    if (low->x < high->x)
    {
        if (!high->left)
            high->left = low;
        else
            insert_node(high->left, low);
    }
    else
    {
        if (!high->right)
            high->right = low;
        else
            insert_node(high->right, low);
    }
}

void pre(node* cur, vector<int>& ret)
{
    if (!cur) return;
    ret.push_back(cur->idx);
    pre(cur->left, ret);
    pre(cur->right, ret);
}

void post(node* cur, vector<int>& ret)
{
    if (!cur) return;
    post(cur->left, ret);
    post(cur->right, ret);
    ret.push_back(cur->idx);
}

```
