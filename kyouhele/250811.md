**닉네임**: kyouhele

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 주사위게임3

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/181916

**오늘의 메모(선택)**: 논리연산자 연습파트라서 거- 논리연산자 열심히 써봐라- 하는 부분인데 그거말고 다르게 풀고 싶었습니다. 그렇다고 이게 더 보기좋냐...? 그건 몰??루?

**코드(선택)**:

```C
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// 숫자 네개 중 두개가 같을 총 경우의 수 6
// 3-1 or 2-2 구조 : p,q . 2-1-1 구조 : p,q,r
int solution(int a, int b, int c, int d) {
    int cnt = 0, origin = a, min = a;
    int n[4] = {a,b,c,d};
    int pqr[3] = {0,0,0};

    //서로 같은 숫자 쌍이 몇 개인지 검사
    {
    if (a == b) cnt++;  if (a == c) cnt++;    if (a == d) cnt++;
    if (!cnt) origin = b;                                               //a와 같은 수가 하나도 없다 : 기준점 =b
    if (b == c) cnt++;    if (b == d) cnt++;
    if (!cnt) origin = c;                                               //b와 같은 수가 하나도 없다 : 기준점 =c
    if (c == d) {cnt++;}
    }
    
    for (int i = 0; i < 4; i++)
    {
        if (n[i] != origin)                                //기준수와 다른 숫자가 나오면
        {
            if (pqr[1] && pqr[1] != n[i])                   //근데 이미 다른 숫자가 나온 적 있고 자신이 아니면
                pqr[2] = n[i];                              //r 등장!
            else
                pqr[1] = n[i];                              //q 등장 or 갱신!
        }
        else
           pqr[0] = n[i];
        
        if (min > n[i]) //모든 수 다를 때 리턴하기 위한 min검사
            min = n[i];
    }

    if (cnt == 6)
        return 1111 * pqr[0];
    if (cnt == 3)
        return ((10 * pqr[0] + pqr[1]) * (10 * pqr[0] + pqr[1]));
    if (cnt == 2)
        return ((pqr[0] + pqr[1]) * (pqr[0] - pqr[1] > 0 ? pqr[0] - pqr[1] : pqr[1] - pqr[0]));
    if (cnt == 1)
        return (pqr[1] * pqr[2]);
    if (cnt == 0)
        return (min);
}
```
