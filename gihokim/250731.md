**닉네임**: gihokim

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 1799 / 비숍

**문제 링크**: https://www.acmicpc.net/problem/1799

**오늘의 메모(선택)**: 

내가 이런 문제가 나왔을 때 스스로 시간복잡도를 계산 할 수 있을까?

시간 복잡도:
흑백 미분리: O(2^(N×N))
흑백 분리: O(2^(N×N/2)) (탐색 공간이 제곱근 수준으로 줄어듬)

미분리: 2^64 ≈ 1.8×10¹⁹
분리: 2^32 ≈ 4.3×10⁹

**코드(선택)**:

```c++
#include <iostream>

using namespace std;

#define B 9

int N;
int map[10][10];
int WHITE_MAX_BISHOP = 0;
int BLACK_MAX_BISHOP = 0;
int white_bishop_num = 0;
int black_bishop_num = 0;

int ydir[] = {-1, -1, 1, 1};
int xdir[] = {-1, 1, -1, 1};

void place_bishop(int row, int col) {
    map[row][col] = B;
    if ((row + col) % 2 == 0) {
        black_bishop_num++;
        if (black_bishop_num > BLACK_MAX_BISHOP) BLACK_MAX_BISHOP = black_bishop_num;
    }
    else {
        white_bishop_num++;
        if (white_bishop_num > WHITE_MAX_BISHOP) WHITE_MAX_BISHOP = white_bishop_num;
    }
    
    for (int i = 0; i < 4; i++) {
        int ny = row + ydir[i];
        int nx = col + xdir[i];
        while (ny >= 0 && nx >= 0 && ny < N && nx < N) {
            if (map[ny][nx] <= 0) map[ny][nx]--;
            ny += ydir[i];
            nx += xdir[i];
        }
    }
}

void remove_bishop(int row, int col) {
    map[row][col] = 0;
    if ((row + col) % 2 == 0) black_bishop_num--;
    else white_bishop_num--;
    for (int i = 0; i < 4; i++) {
        int ny = row + ydir[i];
        int nx = col + xdir[i];
        while (ny >= 0 && nx >= 0 && ny < N && nx < N) {
            if (map[ny][nx] < 0) map[ny][nx]++;
            ny += ydir[i];
            nx += xdir[i];
        }
    }
}

void black_dfs(int row, int col) {
    for (int i = row; i < N; i++) {
        if (i == row) {
            for (int j = col + 1; j < N; j++) {
                if ((i + j) % 2 == 0) continue;
                if (map[i][j] != 0) continue;
                place_bishop(i, j);
                black_dfs(i, j);
                remove_bishop(i, j);
            }
        } else {
            for (int j = 0; j < N; j++) {
                if ((i + j) % 2 == 0) continue;
                if (map[i][j] != 0) continue;
                place_bishop(i, j);
                black_dfs(i, j);
                remove_bishop(i, j);
            }
        }
    }    
}

void white_dfs(int row, int col) {
    for (int i = row; i < N; i++) {
        if (i == row) {
            for (int j = col + 1; j < N; j++) {
                if ((i + j) % 2 == 1) continue;
                if (map[i][j] != 0) continue;
                place_bishop(i, j);
                white_dfs(i, j);
                remove_bishop(i, j);
            }
        } else {
            for (int j = 0; j < N; j++) {
                if ((i + j) % 2 == 1) continue;
                if (map[i][j] != 0) continue;
                place_bishop(i, j);
                white_dfs(i, j);
                remove_bishop(i, j);
            }
        }
    }
}

int main() {
    // input
    cin >> N;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> map[i][j];
            if (map[i][j] == 0) map[i][j] = 1;
            else map[i][j] = 0;
        }
    }

    // solve
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if ((i + j) % 2 == 1) continue;
            if (map[i][j] != 0) continue;
            place_bishop(i, j);
            white_dfs(i, j);
            remove_bishop(i, j);
        }
    }
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if ((i + j) % 2 == 0) continue;
            if (map[i][j] != 0) continue;
            place_bishop(i, j);
            black_dfs(i, j);
            remove_bishop(i, j);
        }
    }

    // output
    cout << WHITE_MAX_BISHOP + BLACK_MAX_BISHOP;
}
```
