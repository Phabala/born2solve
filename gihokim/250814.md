**닉네임**: gihokim

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 2143 / 두 배열의 합

**문제 링크**: https://www.acmicpc.net/problem/2143

**오늘의 메모(선택)**: 해쉬맵 find 메소드의 시간 복잡도가 logN 임을 이용한 문제. 해쉬맵의 value 와 답 부분에 long long 을 해야 overflow 가 안 나는 이유는 아직 잘 모르겠는데 내일 더 알아봐야겠다.

**코드(선택)**:

```c++
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

int T, n, m;
vector<int> A;
vector<int> B;
unordered_map<int, long long> aMap; // key: 합, value: 갯수. 가능한 합의 갯수를 map 으로 담는다
unordered_map<int, long long> bMap;

int main() {
	// input & init
	cin >> T;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int num;
		cin >> num;
		A.push_back(num);
	}
	cin >> m;
	for (int i = 0; i < m; i++) {
		int num;
		cin >> num;
		B.push_back(num);
	}

	// solve
	for (int i = 0; i < n; i++) { // O(n * (n+1) / 2 * logn) ~= 1,500,000회
		int num = 0;
		for (int j = i; j < n; j++) {
			num += A[j];
			auto it = aMap.find(num);
			if (it == aMap.end()) aMap.insert({num, 1});
			else it->second++;
		}
	}
	for (int i = 0; i < m; i++) { // O(m * (m+1) / 2 * logm) ~= 1,500,000 회
		int num = 0;
		for (int j = i; j < m; j++) {
			num += B[j];
			auto it = bMap.find(num);
			if (it == bMap.end()) bMap.insert({num, 1});
			else it->second++;
		}
	}
	
	long long ans = 0;
	for (auto a_it = aMap.begin(); a_it != aMap.end(); a_it++) { // ~= 1,500,000 * 5log15회 ~= 10,000,000회
		auto b_it = bMap.find(T - a_it->first);
		if (b_it != bMap.end()) ans += (a_it->second * b_it->second);
	}

	cout << ans;
}
```
