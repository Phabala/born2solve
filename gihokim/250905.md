**닉네임**: gihokim

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 1916 / 최소비용 구하기

**문제 링크**: https://www.acmicpc.net/problem/1916

**오늘의 메모(선택)**:

다익스트라로 풀면 목적지에 도착한 경우 continue 가 아니라 break 를 해도 된다고 한다.

**코드(선택)**:

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

int N, M;
int st, dst;

class Node {
public:
	int from, to, cost;
	Node(int from, int to, int cost) : from(from), to(to), cost(cost) {}
	const bool operator< (const Node& other) const { return cost > other.cost; }
};

vector<vector<Node>> adj;

int main() {
	// input & init
	cin >> N >> M;

	adj = vector<vector<Node>>(N + 1);
	
	int from, to, cost;
	for (int i = 0; i < M; i++) {
		cin >> from >> to >> cost;
		adj[from].push_back(Node(from, to, cost));
	}

	cin >> st >> dst;

	// solve
	int ans = 21e8;
	vector<int> minCost = vector<int>(N + 1, 21e8);
	priority_queue<Node> pq;

	minCost[st] = 0;
	pq.push(Node(0, st, 0));

	while (!pq.empty()) {
		Node now = pq.top();
		pq.pop();

		if (now.cost > minCost[now.to]) continue;
		if (now.to == dst) {
			ans = now.cost;
			break;
		}

		for (Node node : adj[now.to]) {
			if (minCost[node.to] > now.cost + node.cost) {
				pq.push(Node(now.from, node.to, now.cost + node.cost));
				minCost[node.to] = now.cost + node.cost;
			}
		}
	}

	// output
	cout << ans;
}
```
