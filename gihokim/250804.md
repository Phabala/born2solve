**닉네임**: gihokim

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 1005 / ACM Craft

**문제 링크**: https://www.acmicpc.net/problem/1005

**오늘의 메모(선택)**: 

`위상 정렬`: 순환하지 않는 유향 그래프를 방향성에 거스르지 않도록 순서대로 배열하는 방법.

예로 대학의 선수과목 구조를 예로 들 수 있다. (B라는 과목을 듣기 위해 A라는 과목을 들어야 하는 등 순서가 복잡한 경우 어느 순서대로 과목을 수강해야 하는지 찾는 알고리즘)

시간 복잡도: 꼭짓점의 양수 노드의 선형 실행 시간을 가진다. `O(|V| + |E|)`

푸는 방법은 `Kahn` 알고리즘과 `DFS` 가 있다.

Kahn:
1. 진입차수가 0인 노드를 전부 큐 Q에 집어넣는다.
2. 큐에서 노드 하나를 뽑아 해당 노드가 가리키는 모든 노드의 진입차수를 1씩 줄인다.
3. 큐가 빌 때까지 2를 반복한다.
4. 그래프가 완전히 비지 않았다면 1로 돌아간다.

DFS:
1. 임의의 노드 S를 고른다.
2. DFS로 그래프를 탐색하며 진출차수가 0인 노드에서 멈춘다.
3. 해당 노드를 스택에 넣는다.
4. 2로 돌아가 다시 거슬러 올라가 탐색한다.
5. 만약 더이상 갈 수 있는 곳이 없다면 다시 임의의 노드 S2를 골라 2로 돌아간다.
6. 그래프가 빌 때까지 반복한다.

---

`가중치 있는 위상 정렬`: dp 에 '선행 수행 시간' + '해당 작업 수행 시간' 을 메모해야 한다.


**코드(선택)**:

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int T, N, K, W;
vector<int> buildTime;
vector<vector<int>> adj; // 간선(index: from, value: to)
vector<int> indegree; // 진입차수(자신을 가리키는 노드의 수)
vector<int> memo; // 선행 건물 + 현재 건물 완료 시간

int main() {
    cin >> T;
    for (int tc = 1; tc <= T; tc++) {
        // input
        cin >> N >> K;

        // reset
        buildTime.clear();
        buildTime.push_back(0);
        for (int i = 1; i <= N; i++) {
            int time;
            cin >> time;
            buildTime.push_back(time);
        }

        adj = vector<vector<int>>(N + 1, vector<int>());
        indegree = vector<int>(N + 1);
        for (int i = 0; i < K; i++) {
            int from, to;
            cin >> from >> to;
            adj[from].push_back(to);
            indegree[to]++;
        }

        memo = vector<int>(N + 1);
        for (int i = 1; i <= N; i++) // 선행 건물이 없는 경우 해당 건물을 짓는데 걸리는 최소 시간은 buildTime[i]
            if (indegree[i] == 0) memo[i] = buildTime[i];

        // solve
        queue<int> q;
        for (int i = 1; i <= N; i++)
            if (indegree[i] == 0) q.push(i);
        
        while (!q.empty()) {
            int now = q.front();
            q.pop();
            for (int to : adj[now]) {
                memo[to] = max(memo[now] + buildTime[to], memo[to]);
                indegree[to]--;
                if (indegree[to] == 0)
                    q.push(to);
            }
        }

        // output
        cin >> W;
        cout << memo[W] << '\n';
    }
}
```
