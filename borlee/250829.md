**닉네임**: borlee

**문제 플랫폼**: leetcode

**문제 이름 또는 번호**: 47. Permutations II

**문제 링크**: https://leetcode.com/problems/permutations-ii/description/

**오늘의 메모(선택)**: 기존 순열 c코드에 중복 숫자를 건너뛰도록 수정한 백트래킹을 구현했다.

**코드(선택)**:

```c

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct s_perm
{
    int *nums;
    int numsSize;
    int **result;
    int *returnColumnSizes;
    int returnSize;
}   t_perm;

static void swap(int *a, int *b);
static void save_permutation(t_perm *p);
static void backtrack(t_perm *p, int start);

int **permute(int *nums, int numsSize, int *returnSize, int **rerturnColumnSizes)
{
    int maxPermutations;
    int i;
    int **result;
    t_perm p;

    maxPermutations = 1;
    i = 2;
    while (i <= numsSize)
    {
        maxPermutations *= i;
        i++;
    }
    result = malloc(maxPermutations * sizeof(int *));
    if(!result)
        return NULL;
    *rerturnColumnSizes = malloc(maxPermutations * sizeof(int));
    if (!rerturnColumnSizes)
        return NULL;
    *returnSize = 0;
    p.nums = nums;
    p.numsSize = numsSize;
    p.result = result;
    p.returnColumnSizes = *rerturnColumnSizes;
    p.returnSize = *returnSize;

    backtrack(&p, 0);
    *returnSize = p.returnSize;
    return result;
}

static void swap(int *a, int *b)
{
    int tmp;
    tmp = *a;
    *a = *b;
    *b = tmp;
}

static void save_permutation(t_perm *p)
{
    int *permutation;
    int i;

    permutation = malloc(p->numsSize * sizeof(int));
    if (!permutation)
        return ;
    i = 0;
    while (i < p->numsSize)
    {
        permutation[i] = p->nums[i];
        i++;
    }
    p->result[p->returnSize] = permutation;
    p->returnColumnSizes[p->returnSize] = p->numsSize;
    p->returnSize++;
}

static void backtrack(t_perm *p, int start)
{
    int i;
    
    if (start == p->numsSize)
    {
        save_permutation(p);
        return;
    }
    i = start;
    while (i < p->numsSize)
    {
        swap(&(p->nums[start]), &(p->nums[i]));
        backtrack(p, start + 1);
        swap(&(p->nums[start]), &(p->nums[i]));
        i++;
    }
}

int main(void)
{
    int nums[] = {0,1};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int returnSize;
    int *returnColumnSizes;
    int **result;

    result = permute(nums, numsSize, &returnSize, &returnColumnSizes);
    printf("===result===\n");
    for (int i = 0; i < returnSize; i++)
    {
        printf("[");
        for (int j = 0; j < numsSize; j++)
        {
            printf("%d", result[i][j]);
            if (j < numsSize - 1)
                printf(", ");
        }
        printf("]\n");
    }
    for (int i = 0; i < returnSize; i++)
    {
        free(result[i]);
    }
    free(result);
    free(returnColumnSizes);
    return 0;
}

```
