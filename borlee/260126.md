**닉네임**: borlee

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 섬 연결하기

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/42861

**오늘의 메모(선택)**: 
union-find 복습용. union, find 함수는 외워놓고 쓸만하다.
edges_count = n-1 은 불필요한 루프를 조기 종료하기 위한 부분이다.
greedy 문제를 좀 더 풀어봐야 할 것 같다.
-- 아직 풀기는 어려운 난이도지만, 공부용으로 기록

**코드(선택)**
```python
from typing import List

def find(parent: List[int], i: int) -> int:
    if parent[i] == i:
        return i
    parent[i] = find(parent, parent[i])
    return parent[i]

def union(parent: List[int], rank: List[int], x: int, y: int) -> None:
    xroot: int = find(parent, x)
    yroot: int = find(parent, y)
    
    if rank[xroot] < rank[yroot]:
        parent[xroot] = yroot
    elif rank[xroot] > rank[yroot]:
        parent[yroot] = xroot
    else:
        parent[yroot] = xroot
        rank[xroot] += 1

    # 위까지가 Union-find 알고리즘 구현

def solution(n: int, costs: List[List[int]]) -> int:
    # 간선이 적은 그래프에서는 kruskal 
    costs.sort(key=lambda x: x[2])
    
    parent: List[int] = [i for i in range(n)]
    rank: List[int] = [0] * n
    min_cost: int = 0
    edges_count: int = 0
    
    for edge in costs:
        if edges_count == n - 1:# n-1개의 간선이 선택되면 종료
            break
            
        u: int = edge[0]
        v: int = edge[1]
        weight: int = edge[2]
        
        root_u: int = find(parent, u)
        root_v: int = find(parent, v)
        
        # 사이클이 형성되지 않는 경우에만 , 사이클(순환 경로)가 생기지 않게!
        if root_u != root_v:
            union(parent, rank, root_u, root_v)
            min_cost += weight
            edges_count += 1
            
    return min_cost
```