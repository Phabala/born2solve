**닉네임**: borlee

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 사라지는 발판

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/92345

**오늘의 메모(선택)**: 
공부를 위한 코드다 (내 코드 아님)
백트래킹을 이해한 것 같으면서도 아직 잘 모르겠다. 

**코드(선택)**
```python
def solution(board, aloc, bloc):
    ROW, COL = len(board), len(board[0]) # 게임판의 행, 열 저장
    DR, DC = [-1, 0, 1, 0], [0, 1, 0, -1]
    
    # 주어진 위치가 유효한 위치인가?
    def is_valid_pos(r, c):
        return 0 <= r < ROW and 0 <= c < COL
    
    # 재귀적 호출
    def recursive_func(alpha_pos, beta_pos, visited, step):
        # 현재 플레이어의 위치와 이동 가능 여부와
        # 상대 플레이어가 이긴 경우를 저장하는 변수들
        r, c = alpha_pos if step % 2 == 0 else beta_pos
        can_move = False
        is_opponent_winner = True
        # 이긴 경우와 진 경우 저장하는 리스트
        win_steps, lose_steps = [], []
        
        # 현재 위치에서 이동할 수 있는 모든 방향으로 이동
        for i in range(4):
            nr, nc = r + DR[i], c + DC[i]
            # 이동할 수 있다면
            if is_valid_pos(nr, nc) and (nr, nc) not in visited and board[nr][nc]:
                can_move = True
                # 두 플레이어 위치가 같다면 A가 이김. True, step + 1 반환
                if alpha_pos == beta_pos:
                    return True, step + 1
                # 재귀적으로 호출하여 이긴 여부와 남은 툰수 가져오기
                win, steps_left = (
                    recursive_func([nr, nc], beta_pos, visited | {(r, c)}, step + 1)
                    # 방문한 칸을 기록하는 visited 와 (r, c) 합집합 
                    if step % 2 == 0
                    else recursive_func(
                        alpha_pos, [nr, nc], visited | {(r, c)}, step + 1
                    )              
                )
                # 상대 플레이어가 이긴 경우만 True
                is_opponent_winner &= win 
                # 이긴 경우와 진 경우 저장
                (win_steps if win else lose_steps).append(steps_left)
                
        # 만약 이동할 수 있는 위치가 없다면
        if not can_move:
            return False, step
        # 상대 플레이어가 이긴 경우
        if is_opponent_winner:
            return False, max(win_steps)
        # 현재 플레이어가 이긴 경우
        return True, min(lose_steps)
    
    # A 플레이어가 이길 때까지 걸리는 최소 턴 수를 반환
    # _ = 이 값은 사용하지 않을 것이다.
    _, steps = recursive_func(aloc, bloc, set(), 0)
    return steps
    
```