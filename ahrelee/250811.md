**닉네임**: ahrelee

**문제 플랫폼**: leetcode

**문제 이름 또는 번호**: #707. Design Linked List

**문제 링크**: https://leetcode.com/problems/design-linked-list/description/

**오늘의 메모(선택)**: doubly linked list // 첫 노드, 중간 노드, 마지막 노드를 각자 관리하는 것이 핵심
runtime: 9ms, Memory: 26.1MB

**코드(선택)**: 

```cpp

struct Node {
    int _value;
    Node *_prev;
    Node *_next;
    Node(int value)
        : _value(value), _prev(nullptr), _next(nullptr) {}
};

class MyLinkedList {
public:
    MyLinkedList( void )
        : _size(0) {
        _head = new Node(0);
        _head->_prev = _head;
        _head->_next = _head;
    }
    
    int get(int index) {
        if (index < 0 || index >= _size)
            return (-1);
        Node* current = _head;
        for (int idx = 0; idx < index; ++idx) {
            current = current->_next;
        }
        return (current->_value);
    }
    
    void addAtHead(int val) {
        Node* new_node = new Node(val);
        new_node->_next = _head;
        if (_size > 0) {
            _head->_prev = new_node;
        }
        _head = new_node;
        ++_size;
    }
    
    void addAtTail(int val) {
        if (_size == 0){
            return (addAtHead(val));
        }
        Node* new_node = new Node(val);
        Node* current = _head;
        for (int idx = 0; idx < _size - 1; ++idx) {
            current = current->_next;
        }
        new_node->_prev = current;
        current->_next = new_node;
        ++_size;
    }
    
    void addAtIndex(int index, int val) {
        if (index > _size || index < 0)
            return ;
        if (index == 0) {
            return (addAtHead(val));
        }
        if (index == _size) {
            return (addAtTail(val));
        }
        Node* new_node = new Node(val);
        Node* current = _head;
        for (int idx = 0; idx < index; ++idx) {
            current = current->_next;
        }
        new_node->_prev = current->_prev;
        new_node->_next = current;
        current->_prev->_next = new_node;
        current->_prev = new_node;
        ++_size;
    }
    
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0)
            return ;
        if (_size == 1 && index == 0) {
            delete _head;
            _head = NULL;
            --_size;
            return ;
        }
        Node* current = _head;
        for (int idx = 0; idx < index; ++idx) {
            current = current->_next;
        }
        if (index == 0) {
            _head = current->_next;
            _head->_prev = nullptr;
        } else {
            if (current->_next) {
                current->_next->_prev = current->_prev;
            } if (current->_prev) {
                current->_prev->_next = current->_next;
            }
        }
        delete current;
        current = NULL;
        --_size;
    }


private:
    Node* _head;
    int _size;
};

```