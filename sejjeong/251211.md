**닉네임**: sejjeong

**문제 플랫폼**: 프로그래머스


**문제 이름 또는 번호**: 
                단어 변환

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/43163


**오늘의 메모(선택)**: 
            인접 행렬 없어도 됨.. isMovable만 있어도 되네...

**코드(선택)**:



```C++

#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <climits>
#include <iostream>

using namespace std;


bool isMovable(const string& begin, const string& target)
{
    int difCount = 0;
    for (int k = 0; k < begin.size(); ++k)
    {
        if (begin[k] != target[k])
        {
            ++difCount;
            if (difCount > 1)
            {
                return false;
            }
        }
    }
    return difCount != 0 ? true : false; 
}


int solution(string begin, string target, vector<string> words) {
    
    // 길이 3~10, 단어의 길이는 모두 같음
    // words 3~50개 중복 x
    // begin != target
    // 변환 못하면 0
    

    // dog hog dog hog 이러면서 무한 반복이 될 수도 있음
    // 저 문자로 변환이 되는지 체크하는 함수가 있어야 될 거 같고
    // 
    
    // 최소니까 너비로 봐야 하나
    // 한 번에 하나라고 했음
    // 자리를 바꿀 수 있는 문자가 있는지 체크하기
    // 이미 바꿨던 문자는 HashSet에 넣어두고
    // 해당 문자로 바뀌는데 최소치?
    
    // 문자마다 그래프를 만들어주어도 되겠는데(방향 그래프)
    // 인접 행렬 만들까? (index 매핑 해야 함)
    // unordered_map으로 인접리스트를 만들까?
    
    // begin도 안에 넣어주자.
    words.insert(words.begin(), begin);
    
    // 최소 카운트 담아줄 곳
    vector<int> minPaths(words.size(), INT_MAX);
    bool** adjMat = new bool*[words.size()];
    int targetIndex = 0;
    for (int i = 0; i < words.size(); ++i)
    {
        if (words[i] == target)
        {
            targetIndex = i;
        }
        adjMat[i] = new bool[words.size()];
        adjMat[i][0] = false;
        for (int j = 1; j < words.size(); ++j)
        {
            if (isMovable(words[i], words[j]))
            {
                adjMat[i][j] = true;
            }
            else
            {
                adjMat[i][j] = false;
            }
        }
    }

    int size = words.size();
    unordered_set<int> discovered;
    // bfs 하기
    queue<int> q;
    queue<int> distances;
    q.push(0);
    distances.push(0);
    discovered.insert(0);
    while (q.size() != 0)
    {
        int current = q.front();
        q.pop();
        
        int distance = distances.front();
        distances.pop();
        
        if (distance < minPaths[current])
        {
            minPaths[current] = distance;
        }

        for (int j = 0; j < size; ++j)
        {
            bool isMovable = adjMat[current][j] && discovered.find(j) == discovered.end();
            if (isMovable) 
            {
                discovered.insert(j);
                q.push(j);
                distances.push(distance + 1);
            }
        }
    }
    discovered.clear();

    for (int i = 0; i < size; ++i)
    {
        delete[] adjMat[i];
    }
    delete[] adjMat;
    
    // for (int i = 0; i < minPaths.size(); ++i)
    // {
    //     std::cout << minPaths[i] << std::endl;
    // }
    
    return minPaths[targetIndex] != INT_MAX ? minPaths[targetIndex] : 0;
}

```