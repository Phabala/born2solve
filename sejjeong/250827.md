**닉네임**: sejjeong

**문제 플랫폼**: leetcode

**문제 이름 또는 번호**: Kth Largest Element in an Array

**문제 링크**: https://leetcode.com/problems/merge-sorted-array/

**오늘의 메모(선택)**: 
					1. Lomuto Quick Sort 응용한 풀이(개느림), Hoare를 사용한 풀이는 훨씬 빠름
					2. sort 라이브러리 써도 상관 없다.
					3. 알고보니 더 간단한 딸칵 함수가 있었다. nth_element()
					4. 우선순위 큐도 나쁘지 않은 듯 하다.
					5. map을 이용해도 될 듯
					
					
**코드(선택)**:

C++

```
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {

        int position = findKthLargestRecursive(nums, 0, static_cast<int>(nums.size()) - 1, k);
        return nums[position];
    }

    int findKthLargestRecursive(vector<int>& nums, int left, int right, int k)
    {
        int pivotPos = fixPivot(nums, left, right);
        if (pivotPos == nums.size() - k)
        {
            return pivotPos;
        }

        if (left < pivotPos - 1)
        {
            int result = findKthLargestRecursive(nums, left, pivotPos - 1, k);
            if (result == nums.size() - k)
            {
                return result;
            }
        }
        else
        {
            if (left == nums.size() - k)
            {
                return left;
            }
        }

        if (pivotPos + 1 < right)
        {
            int result = findKthLargestRecursive(nums, pivotPos + 1, right, k);
            if (result == nums.size() - k)
            {
                return result;
            }
        }
        else
        {
            if (right == nums.size() - k)
            {
                return right;
            }
        }

        return -1;
    }

  

    int fixPivot(vector<int>& nums, int left, int right)
    {
        int pivot = nums[right];
        int pivotPos = left;

        for (int i = left; i < right; ++i)
        {
            if (nums[i] < pivot)
            {
                std::swap(nums[pivotPos], nums[i]);
                ++pivotPos;
            }
        }
        std::swap(nums[pivotPos], nums[right]);
        return pivotPos;
    }
};

```
