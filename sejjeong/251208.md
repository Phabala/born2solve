**닉네임**: sejjeong

**문제 플랫폼**: 프로그래머스


**문제 이름 또는 번호**: 
                피로도

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/87946


**오늘의 메모(선택)**: 
            그리디로 하니까 틀림, 완탐 문제라고 적혀 있음 말을 잘 들을 것... 괜히 청개구리 짓 하지 말 것... 
            왜 그리디가 안 되는지 반례에 대한 증명 말고 다른 증명으로도 할 수 있으면 좋을 거 같다. 

**코드(선택)**:



```C++

#include <string>
#include <vector>
#include <unordered_set>
#include <climits>
#include <iostream>

#define MAX(a, b) (a > b ? a : b)

using namespace std;


int findMaxDungeonCountRecursive(const int k, unordered_set<int>& indices, vector<vector<int>>& dungeons)
{
    if (k < 0)
    {
        std::cout << "error" << std::endl;
    }
    
    int count = 0;
    for (int i = 0; i < dungeons.size(); ++i)
    {
        int min = dungeons[i][0];
        int use = dungeons[i][1];
        if (indices.find(i) != indices.end() || min > k || use > k)
        {
            continue;
        }
        indices.insert(i);
        count = MAX(count, findMaxDungeonCountRecursive(k - use, indices, dungeons));
        indices.erase(i);
    }
    return MAX(count, indices.size());
}

int solution(int k, vector<vector<int>> dungeons) {
    
    // 완탐이라고 하는데
    // 순열인가보다
    
    unordered_set<int> indices;
    return findMaxDungeonCountRecursive(k, indices, dungeons);    
    

    // 그리디 풀이 틀림
//     while (true)
//     {
//         int bestIndex = -1;
//         int maxCount = -1;
//         bool isFound = false;
//         for (int i = 0; i < dungeons.size(); ++i)
//         {
//             bool isNotExpedition = k - dungeons[i][0] < 0;
//             if (isNotExpedition)
//             {
//                 continue;
//             }
            
//             isFound = true;
//             k -= dungeons[i][1];
//             int remainCount = 0;
//             for (int j = 0; j < dungeons.size(); ++j)
//             {
//                 if (i == j)
//                 {
//                     continue;
//                 }
//                 if (k >= dungeons[j][0] && k >= dungeons[j][1])
//                 {
//                     ++remainCount;
//                 }
//             }
//             k += dungeons[i][1];
//             if (maxCount < remainCount)
//             {
//                 bestIndex = i;
//                 maxCount = remainCount;
//             }
//         }
//         if (isFound == false)
//         {
//             break;
//         }
//         k -= dungeons[bestIndex][1];
//         dungeons[bestIndex][1] = 10000;
//         ++answer;
//     }    
//     return answer;
}




```