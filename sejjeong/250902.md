**닉네임**: sejjeong

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 전화번호 목록

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/42577

**오늘의 메모(선택)**: 
                해시 자료구조를 잘 쓰면, O(1)으로 접근할 수 있으니 성능상 매우 큰 이점으로 옴.
                코드를 구현할 때, 쿼리하는 방향으로 만들기  
					
**코드(선택)**:

C++

```

제한 사항
phone_book의 길이는 1 이상 1,000,000 이하입니다.
각 전화번호의 길이는 1 이상 20 이하입니다.
같은 전화번호가 중복해서 들어있지 않습니다.

#include <string>
#include <vector>
#include <cstring>
#include <unordered_set>

using namespace std;

bool solution(vector<string> phone_book) {
    
    unordered_set<string> set;
    for (size_t i = 0; i < phone_book.size(); ++i)
    {
        set.insert(phone_book[i]);
    }
    
    for (string phone : set)
    {
        // 제한사항을 보면 길이만큼 반복하는 것은 최대 20밖에 안 들고, for문을 돌리는 것은 100만 번까지 높아질 수 있음
        for (size_t i = 1; i < phone.size(); ++i)
        {
            if (set.find(string(phone.c_str(), i)) != set.end())
            {
                return false;
            }
        }
    }

    // for (size_t i = 0; i < phone_book.size(); ++i)
    // {
    //     for (size_t j = i + 1; j < phone_book.size(); ++j)
    //     {
    //         if (strncmp(phone_book[i].c_str(), phone_book[j].c_str(), phone_book[i].size()) == 0
    //             || strncmp(phone_book[j].c_str(), phone_book[i].c_str(), phone_book[j].size()) == 0)
    //         {
    //             return false;
    //         }
    //     }
    // }
    
    return true;
}
```
