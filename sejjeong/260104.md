**닉네임**: sejjeong

**문제 플랫폼**: 프로그래머스


**문제 이름 또는 번호**: 
                등굣길(Lv3, 정답률 61%)

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/17680


**오늘의 메모(선택)**: 
            DP 문제
            unordered_set을 사용하려 하니, HashCode를 만들어 주어야 해서 set으로 변경함

**코드(선택)**:



```C++

#include <string>
#include <cstring>
#include <vector>
#include <stack>
#include <set>


using namespace std;

int solution(int m, int n, vector<vector<int>> puddles) {
 
    // 격자마다 경우의 수를 만들기
    set<pair<int, int>> puddleSet;
    for (int i = 0; i < puddles.size(); ++i)
    {
        int x = puddles[i][0];
        int y = puddles[i][1];
        puddleSet.insert(pair<int, int>(y - 1, x - 1));
    }
    
    int* grid = new int[n * m];
    memset(grid, 0, sizeof(int) * n * m);
    for (int i = 0; i < m; ++i)
    {
        if (puddleSet.find(pair<int, int>(0, i)) != puddleSet.end())
        {
            break;
        }
        grid[i] = 1;
    }
    
    const int MODULAR = 1000000007;
    for (int y = 1; y < n; ++y)
    {
        if (puddleSet.find(pair<int, int>(y - 1, 0)) == puddleSet.end())
        {
            grid[y * m] += grid[(y - 1) * m];
            grid[y * m] %= MODULAR;
        }
        for (int x = 1; x < m; ++x)
        {
            if (puddleSet.find(pair<int, int>(y, x - 1)) == puddleSet.end())
            {
                grid[y * m + x] += grid[y * m + x - 1];
                grid[y * m + x] %= MODULAR;
            }
            
            if (puddleSet.find(pair<int, int>(y - 1, x)) == puddleSet.end())
            {
                grid[y * m + x] += grid[(y - 1) * m + x];
                grid[y * m + x] %= MODULAR;
            }
        }
    }
    
    delete[] grid;
    
    return grid[n * m - 1];
}

```