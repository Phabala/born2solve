**닉네임**: micha

**문제 플랫폼**: 프로그래머스

**문제 이름 또는 번호**: 특이한 정렬

**문제 링크**: https://school.programmers.co.kr/learn/courses/30/lessons/120880

**오늘의 메모(선택)**:

내가 푼 방식에서의 문제점 : n이 작거나 클때의 예외처리 부족하였음


정식 풀이 : 

int[]는 Comparator 정렬 불가
Comparator를 쓰려면 객체 배열 (Integer[])이 필요함
그래서 int[] -> Integer[] 변환 후 정렬

스트림을 쓴 이유
int[] -> Integer[]를 한 줄로 깔끔하게 표현하려고 사용

배열을 스트림으로 꺼냄
int -> Integer로 포장(boxed)
다시 Integer[] 배열로 만듦

boxed()정리
boxed() = 기본형 스트림 -> 래퍼 객체 스트림
IntStream -> Stream<Integer>
무조건 Integer가 아니라 기본형에 대응되는 객체로 변환

Comparator가 (a, b)를 비교할 때,
return < 0 (음수) : a를 앞에 둬라
return > 0 (양수) : b를 앞에 둬라
return == 0 : a와 b의 순서를 동일 취급

**코드(선택)**:

```java

// 정식 풀이

class Solution {
    public int[] solution(int[] numlist, int n) {
        Integer[] arr = Arrays.stream(numlist).boxed().toArray(Integer[]::new);

        Arrays.sort(arr, (a, b) -> {
            int da = Math.abs(a - n);
            int db = Math.abs(b - n);
            if (da != db) return da - db;  // 거리 가까운 순
            return b - a;                  // 거리 같으면 큰 수 먼저
        });

        return Arrays.stream(arr).mapToInt(Integer::intValue).toArray();
    }
}



// 내가 푼 방식

class Solution {
    public int[] solution(int[] numlist, int n) {
        int n_idx = 0;
        int check = 0;
        int[] answer = new int[numlist.length];

        if (numlist.length == 0)
            return answer;
        
        for (int i = 0; i < numlist.length - 1; i++)  //
        {
            for (int j = i + 1; j < numlist.length; j++)
            {
                if (numlist[i] > numlist[j])
                {
                    int tmp = numlist[j];
                    numlist[j] = numlist[i];
                    numlist[i] = tmp;
                }
            }
        }
        
        // for (int i = 0; i < numlist.length; i++)
            // System.out.println(numlist[i]);
        
        for (int i = 0; i < numlist.length; i++)
        {
            if (numlist[i] == n)
            {
                n_idx = i;
                check = 1;
                break;
            }
        }
        int idx1 = n_idx - 1;
        int idx2 = n_idx + 1;
        
        
        if (check == 0) {
            if (n < numlist[0]) {              // ✅ n이 최소보다 작으면
                idx1 = -1;
                idx2 = 0;
            } else if (n > numlist[numlist.length - 1]) { // ✅ n이 최대보다 크면
                idx1 = numlist.length - 1;
                idx2 = numlist.length;          // 범위 밖으로 보내서 아래 while에서 idx1만 처리되게
            } else {
                for (int i = 0; i < numlist.length - 1; i++) { //
                    if (numlist[i] < n && n < numlist[i + 1]) {
                        idx1 = i;
                        idx2 = i + 1;
                        break;
                    }
                }
            }       
        }
            
        int number = 0;
        int i = 0;
        
        if (check == 1)
            answer[i++] = numlist[n_idx];
        while (idx1 >= 0 && idx2 <= numlist.length - 1 && i < numlist.length)
        {
            
            number = check_min_number(numlist[idx1], numlist[idx2], n);
            answer[i] = number;
            if (number == numlist[idx1])
                idx1--;
            else if (number == numlist[idx2])
                idx2++;
            i++;
        }
        while (idx1 >= 0 && i < numlist.length)
            answer[i++] = numlist[idx1--];
        while (idx2 <= numlist.length - 1 && i < numlist.length)
            answer[i++] = numlist[idx2++];
            
        return answer;
    }
    
    public int check_min_number(int a, int b, int pivot)
    {
        int gab1 = pivot - a;
        int gab2 = pivot - b;
        
        if (gab1 < 0)
            gab1 = -gab1;
        if (gab2 < 0)
            gab2 = -gab2;
        
        if (gab1 < gab2)
            return a;
        else if (gab1 > gab2)
            return b;
        else
            return a > b ? a : b;            

    }
    
}


    


    


\```
