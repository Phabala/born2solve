**닉네임**: sangseo

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 2164 / 카드2

**문제 링크**: https://www.acmicpc.net/problem/2164

**오늘의 메모(선택)**: 1~n까지의 숫자 카드가 아래로 갈수록 커지는 순서로 쌓여있을 때, 맨 위의 카드를 한장 버리고, 한장 밑으로 옮기고를 한장남을때까지 반복하여 그 남은 한장이 무슨 숫자인지 출력하는 문제였다. 자료구조 큐를 이용하는 문제인데, 난 그냥 리스트에 1~n을 때려넣고 탑 지우고 탑 내리고를 반복문으로 하나남을때까지 전부 돌려서 구했었는데 바로 시간 초과... 그래서 내가 구현한걸 n에 1~16까지 넣어보니 패턴을 알게되어서 패턴 계산해서 출력시켰더니 통과되었다. 이후 알아보니 list가 아닌 collections 라이브러리의 deque를 사용하여 같은 방식으로 풀면 시간복잡도가 줄어들어 통과된다고 한다.

아래는 그 이유이다.(list와 deque의 구조와 메소드 동작 관점에서의 설명)
CPython의 list는 연속된 메모리(동적 배열)로 구현됨.
앞에서 빼기 pop(0)을 하면, index 1 ~ -1까지 전부 왼쪽으로 한 칸씩 미는 메모리 복사가 이뤄짐. 그래서 호출 한번마다 O(n)이고, 거의 리스트 길이 이상만큼 O(n)을 반복하니 O(n^2)의 시간복잡도가 되어, n이 커지면 시간 초과가 발생함.
deque는 고정 크기 블록들을 이은 양방향 연결 구조의 block-linked 방식이라. 양 끝의 블록을 떼거나 붙일때, head/tail 포인터만 움직이면 되기 때문에 O(1)의 시간복잡도를 가짐. 따라서 전체 O(n)정도의 시간정도만 발생하므로 통과 가능.

**코드(선택)**:
```python
n = int(input())
total = 1
while (total < n):
    total = total * 2
if n != total:
    total = total - (total - n) * 2
print(total)
```
