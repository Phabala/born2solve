닉네임: eonoh

문제 플랫폼: SWEA

문제 이름 또는 번호: 5643 / 키 순서

문제 링크: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXQsLWKd5cDFAUo

오늘의 메모(선택): 두 개의 유향그래프를 사용해야했습니다. 나보다 키가 큰 사람을 담은 그래프, 키가 작은 사람을 담을 그래프를 각각 저장하여 문제를 풀어야했습니다. 무향그래프 사용은 No !!

코드(선택): cpp

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<vector<int>> students(501);
vector<vector<int>> reverse_list(501);
bool isVisited[501];
bool hasCompared[501];
int n, cnt, result = 0;

void init() {
	students.assign(501, {});
	reverse_list.assign(501, {});
	memset(isVisited, 0, sizeof(isVisited));
	cnt = 0;
	result = 0;
}

void dfs(int start) {
	isVisited[start] = true;
	cnt++;
	for (int next : students[start]) {
		if (!isVisited[next]) {
			dfs(next);
		}
	}
}

void dfs_reverse(int start) {
	isVisited[start] = true;
	cnt++;
	for (int next : reverse_list[start]) {
		if (!isVisited[next]) {
			dfs_reverse(next);
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int t;

	cin >> t;
	for (int tc = 1; tc <= t; tc++) {
		int m, a, b;

		cin >> n >> m;
		init();
		for (int i = 0; i < m; i++) {
			cin >> a >> b;
			students[a].push_back(b);
			reverse_list[b].push_back(a);
		}
		for (int i = 1; i <= n; i++) {
			cnt = 0;
			dfs(i);
			dfs_reverse(i);
			if (cnt - 1 == n) {
				result++;
			}
			memset(isVisited, false, sizeof(isVisited));
		}
		cout << '#' << tc << ' ' << result << '\n';
	}
}
```
