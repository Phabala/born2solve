닉네임: eonoh

문제 플랫폼: SWEA

문제 이름 또는 번호: 12510 / 나무 높이

문제 링크: https://swexpertacademy.com/main/code/userProblem/userProblemDetail.do?contestProbId=AYFofW8qpXYDFAR4

오늘의 메모(선택): 각 나무 별 최대 나무 높이와 같아지기 위해 커져야하는 키가 되기 위한 수를 구합니다. 그 다음 그 수를 1과 2의 합으로 만듭니다.(1이 최소가 되도록. 예를 들면 5는 2 2 1 이런식으로) 그 다음 2가 더 많을 경우 최적화를 시켜줍니다. 아이디어를 떠올리는 것이 가장 어려웠던 문제였습니다..

코드(선택): cpp

```cpp
#include <iostream>
#include <cstring>
using namespace std;

#ifndef max
 #define max(a, b) a > b ? a : b
#endif

#ifndef min
 #define min(a, b) a > b ? b : a
#endif

int n, maxHeight, result;
int countOf1, countOf2;
int tree[101];

void init() {
	result = 0;
	countOf2 = 0;
	countOf1 = 0;
	maxHeight = 0;
	memset(tree, 0, sizeof(int));
}

void solve() {
	for (int i = 0; i < n; i++) {
		int diff = maxHeight - tree[i];
		countOf1 += diff % 2;
		countOf2 += diff / 2;
	}
	while (countOf2 > countOf1 && (countOf2 - countOf1) > 1) {
		countOf2--;
		countOf1 += 2;
	}
	int minOfCount = min(countOf1, countOf2);
	int maxOfCount = max(countOf1, countOf2);

	result = minOfCount * 2;
	if (countOf1 == countOf2) {
		return;
	}
	else if (countOf1 > countOf2) {
		result += ((maxOfCount - minOfCount - 1) * 2 + 1);
	}
	else {
		result += ((maxOfCount - minOfCount) * 2);
	}
}

void printResult(int tc) {
	cout << '#' << tc << ' ' << result << '\n';
}

int main() {
	int t, tmp;

	cin >> t;
	for (int tc = 1; tc <= t; tc++) {
		init();

		cin >> n;
		for (int i = 0; i < n; i++) {
			cin >> tree[i];
			maxHeight = max(tree[i], maxHeight);
		}
		solve();
		printResult(tc);
	}
}
```
