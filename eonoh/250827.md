닉네임: eonoh

문제 플랫폼: SWEA

문제 이름 또는 번호: 1251 / 하나로

문제 링크: https://swexpertacademy.com/main/talk/solvingClub/problemView.do?contestProbId=AV15StKqAQkCFAYD&solveclubId=AZgSFKnq9UvHBISV&problemBoxTitle=0826&problemBoxCnt=5&probBoxId=AZjj856q2nPHBITM

오늘의 메모(선택): 크루스칼 알고리즘을 사용하는 문제입니다. 크루스칼 알고리즘이란! 그래프를 가지고 모든 정점을 방문하는 무순환 트리를 만드는데, 그 가중치가 최소가 되도록하는 MST 풀이법 중 하나 ! 이 문제는 크루스칼 알고리즘을 그대로 구현하면 되기는 하는데, 자료형에 유의해야 했습니다.

코드(선택): cpp

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
#include <math.h>
using namespace std;

int n;
long long sum;
int xPos[1001];
int yPos[1001];
int parent[1001];

// 세율: e + 각 해저터널 길이의 제곱의 곱(e * l^2) 만큼 지불

class Edge {
public:
	int x;
	int y;
	int nodeId;
	Edge() {};
	Edge(int x, int y, int nodeId) {
		this->x = x;
		this->y = y;
		this->nodeId = nodeId;
	}
};

long long calculateDistance(Edge e1, Edge e2) {
	long long dx = e1.x - e2.x;
	long long dy = e1.y - e2.y;
	return dx * dx + dy * dy;
}

class EdgeDistance {
public:
	int nodeId1;
	int nodeId2;
	long long distance;
	EdgeDistance() {};
	EdgeDistance(Edge e1, Edge e2) {
		this->nodeId1 = e1.nodeId;
		this->nodeId2 = e2.nodeId;
		this->distance = calculateDistance(e1, e2);
	}
	bool operator<(EdgeDistance &ed) {
		return this->distance < ed.distance;
	}
};

vector<Edge> edge;
vector<EdgeDistance> edgeDistance;

void init() {
	sum = 0;
	edge.clear();
	edgeDistance.clear();
}

int getParent(int id) {
	if (parent[id] == id) return id;
	return parent[id] = getParent(parent[id]);
}

// parent 가 같은지 찾기
bool findParent(int id1, int id2) {
	id1 = getParent(id1);
	id2 = getParent(id2);
	if (id1 == id2) return true;
	return false;
}

void unionParent(int id1, int id2) {
	id1 = getParent(id1);
	id2 = getParent(id2);
	if (id1 < id2) {
		parent[id2] = id1;
	}
	else {
		parent[id1] = id2;
	}
}

int main()
{
	int t, x, y;
	double e;

	cin >> t;
	for (int tc = 1; tc <= t; tc++) {
		cin >> n;
		init();
		for (int i = 0; i < n; i++) {
			cin >> xPos[i];
		}
		for (int i = 0; i < n; i++) {
			cin >> yPos[i];
		}
		cin >> e;
		for (int i = 0; i < n; i++) {
			edge.push_back(Edge(xPos[i], yPos[i], i));
			parent[i] = i;
		}
		for (int i = 0; i < n - 1; i++) {
			for (int j = i + 1; j < n; j++) {
				edgeDistance.push_back(EdgeDistance(edge[i], edge[j]));
			}
		}
		sort(edgeDistance.begin(), edgeDistance.end());
		for (int i = 0; i < edgeDistance.size(); i++) {
			if (!findParent(edgeDistance[i].nodeId1, edgeDistance[i].nodeId2)) {
				sum += edgeDistance[i].distance;
				unionParent(edgeDistance[i].nodeId1, edgeDistance[i].nodeId2);
			}
		}
		long long result = round((double)sum * e);
		cout << "#" << tc << " " << result << "\n";
	}
	return 0;
}
```
