닉네임: eonoh

문제 플랫폼: SWEA

문제 이름 또는 번호: 3952 / 줄 세우기

문제 링크: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWH-GSJ6EhsDFAUG

오늘의 메모(선택): 위상정렬 문제입니다. 위상정렬이란 무순환 유향 그래프(DAG)가 주어졌을 때 한 가지 경로를 결정해주는 알고리즘입니다.

코드(선택): cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

int n, m;
vector<vector<int> > graph;
queue<int> q;
int inDegree[50001];
vector<int> result;

void init() {
	graph.assign(n + 1, vector<int>());
	q = queue<int>();
	memset(inDegree, 0, sizeof(inDegree));
	result.clear();
}

bool topologicalSort() {
	for (int i = 1; i <= n; i ++) {
		if (inDegree[i] == 0) {
			q.push(i);
			inDegree[i]--;
		}
	}
	for (int i = 0; i < n; i++) {
		if (q.empty()) {
			return false;
		}
		int tmp = q.front();
		q.pop();
		result.push_back(tmp);
		for (int x : graph[tmp]) {
			inDegree[x]--;
			if (inDegree[x] == 0) { // 
				q.push(x);
			}
		}
	}
	return true;
}

void printResult(int tc) {
	cout << "#" << tc << " ";
	for (int x : result) {
			cout << x << ' ';
	}
	cout << "\n";
}

int main() {
	int t, u, v;

	cin >> t;
	for (int tc = 1; tc <= t; tc++) {
		cin >> n >> m;
		init();
		for (int i = 0; i < m; i++) {
			cin >> u >> v;
			graph[u].push_back(v);
			inDegree[v] ++;
		}
		topologicalSort();
		printResult(tc);
	}
	return 0;
}
```