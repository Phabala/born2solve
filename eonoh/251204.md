닉네임: eonoh

문제 플랫폼: SWEA

문제 이름 또는 번호: 2112 / 보호필름

문제 링크: https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZgSFKnq9UvHBISV&contestProbId=AV5V1SYKAaUDFAWu&probBoxId=AZil8Z4qAgzHBIP9&type=PROBLEM&problemBoxTitle=0814&problemBoxCnt=5

오늘의 메모(선택): 비트마스킹을 이용한 조합으로 풀었다. 그런데 비트마스킹은 켜진 1의 수가 적은 것부터 돌지 않기 때문에 좀 비효율적인 코드가 된 것같다.. 다음엔 그냥 dfs 로 풀어봐야겠다 메모리도 많이씀ㄷㄷ

코드(선택): java

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Solution {

    static int D, W, K, minn;
    static int [][]map;

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());

        for (int tc = 1; tc <= t; tc++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            D = Integer.parseInt(st.nextToken());
            W = Integer.parseInt(st.nextToken());
            K = Integer.parseInt(st.nextToken());
            map = new int [D][W];
            minn = Integer.MAX_VALUE;

            for (int y = 0; y < D; y++) {
                st = new StringTokenizer(br.readLine());
                for (int x = 0; x < W; x++) {
                    map[y][x] = Integer.parseInt(st.nextToken());
                }
            }
            solution();
            System.out.println("#" + tc + " " + minn);
        }
    }

    // 부분집합 1. 부분집합으로 주입할 층 찾기
    private static void solution() {
        for (int i = 0; i < (1 << D); i++) {
            ArrayList<Integer> selected = new ArrayList<Integer>();
            for (int j = 0; j < D; j++) {
                if ((i & (1 << j)) != 0) {
                    selected.add(j);
                }
            }
            if (minn == Integer.MAX_VALUE || selected.size() < minn) {
                if (isValid(selected)) {
                    minn = Math.min(minn, selected.size());
                }
            }
        }
    }

    // 주입할 곳을 각각 A, B 로 주입했을 때의 경우 찾기
    private static boolean isValid(ArrayList<Integer> selected) {
        for (int i = 0; i < (1 << selected.size()); i++) {
            int[][] dupliactedMap = new int[D][];
            for (int idx = 0; idx < D; idx++) dupliactedMap[idx] = map[idx].clone();
            for (int j = 0; j < selected.size(); j++) {
                if ((i & (1 << j)) != 0) {
                    // 선택 받은 경우 A 주입
                    Arrays.fill(dupliactedMap[selected.get(j)], 0);
                }
                else {
                    // 선택받지 못한 경우 B 주입
                    Arrays.fill(dupliactedMap[selected.get(j)], 1);
                };
            }
            // 주입 후 연속된 K 개의 어쩌고가 없으면 false 리턴
            if (isLongerThanK(dupliactedMap)) {
                return true;
            }
        }
        return false;
    }

    private static boolean isLongerThanK(int[][] duplicatedMap) {
        int count = 0;
        int y = 0;
        for (int x = 0; x < W; x++) {
            count = 0;
            for (y = 0; y < D - 1; y++) {
                if (duplicatedMap[y][x] == duplicatedMap[y + 1][x]) count++;
                else count = 0;
                if (count == K -1) break;
            }
            if (y == D - 1) return false;
        }
        return true;
    }
}

```
