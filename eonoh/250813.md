닉네임: eonoh

문제 플랫폼: SWEA

문제 이름 또는 번호: 2115 / 벌꿀채취

문제 링크: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5V4A46AdIDFAWu&categoryId=AV5V4A46AdIDFAWu&categoryType=CODE&problemTitle=2115&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1

오늘의 메모(선택): 풀고 있는 중입니다. dp 로 각 인덱스까지의 최대 이익을 얻는 곳에서 고민중입니다..

코드(선택): cpp

```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

vector<vector<int>> map;
vector<vector<int>> square;
vector<vector<int>> maxProfit;
vector<vector<int>> dp;
int t, n, m, c;

void init() {
	map.resize(n, vector<int>(n, 0));
	square.resize(n, vector<int>(n, 0));
	dp.resize(n, vector<int>(n, 0));
}

void getMaxProfit(int cnt, int y, int x, int currentProfit, int currentQuantity, int currentX) {
	if (cnt == m) {
		maxProfit[y][x] = max(currentProfit, maxProfit[y][x]);
		return ;
	}
	for (int pick = 0; pick < 2; pick++) {
		// 임시 양 계산(c 랑 비교)
		int tmpQuantity = currentQuantity + pick * map[y][currentX];
		if (tmpQuantity <= c) {
			// c 보다 같거나 작으면 현재 이익 갱신
			currentProfit += square[y][currentX];
			getMaxProfit(cnt + 1, y, x, currentProfit, currentQuantity, currentX + 1);
		}
	}
}

int main() {
	cin >> t >> n >> m >> c;
	init();
	for (int i = 0; i < t; i++) {
		for (int y = 0; y < n; y++) {
			for (int x = 0; x < n; x++) {
				cin >> map[y][x];
				square[y][x] = map[y][x] * map[y][x];
			}
		}
	}
	for (int y = 0; y < n; y++) {
		for (int x = 0; x <= n - m; x++) {
			getMaxProfit(0, y, x, 0, 0, x);
		}
	}
	for (int y = n - 1; y >= 0; y--) {
		for (int x = n - m; x >= 0; x--) {
			dp[y][x] = max();
		}
	}
}
```
