닉네임: eonoh

문제 플랫폼: 백준

문제 이름 또는 번호: 17471 / 게리맨더링

문제 링크: https://www.acmicpc.net/problem/17471

오늘의 메모(선택): 각 선거구를 이룰 수 있는 경우의 수를 조합으로 찾고, 한 경우를 찾을 때마다 각 그룹끼리 연결되어있는지를 검사하는 과정을 거쳤습니다. 그런데 코드가 너무 길어져서 좀 더 스마트하게 코드를 짤 방법을 궁리해봐야할 것 같습니다..

코드(선택): cpp

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <limits.h>
using namespace std;

int n, minimum, result, trueNum;
vector<vector<int> > area(11, vector<int>(10));
int population[11];
bool isPicked[11], visited[11];

void init() {
	for (int i = 0; i <= n; i++) {
		area[i].clear();
	}
	memset(population, 0, sizeof(population));
	memset(isPicked, false, sizeof(isPicked));
	memset(visited, false, sizeof(visited));
	result = 0;
	minimum = INT_MAX;
	trueNum = 0;
}

int checkPickedConnection(int start) {
	queue<int> q;

	q.push(start);
	visited[start] = true;
	int cnt = 1;
	while (!q.empty()) {
		int top = q.front();
		q.pop();
		for (int x : area[top]) {
			if (isPicked[x] && !visited[x]) {
				visited[x] = true;
				q.push(x);
				cnt++;
			}
		}
	}
	int pickedCount = 0;
	for (int i = 1; i <= n; i++) {
		if (isPicked[i] == 1) pickedCount++;
	}
	memset(visited, 0, sizeof(visited));
	if (pickedCount == cnt) return 1;
	return 0;
}

int checkUnpickedConnection(int start) {
	queue<int> q;

	q.push(start);
	visited[start] = true;
	int cnt = 1;
	while (!q.empty()) {
		int top = q.front();
		q.pop();
		for (int x : area[top]){
			if (!isPicked[x] && !visited[x]) {
				visited[x] = true;
				q.push(x);
				cnt++;
			}
		}
	}
	int unpickedCount = 0;
	for (int i = 1; i <= n; i++) {
		if (!isPicked[i]) unpickedCount++;
	}
	memset(visited, 0, sizeof(visited));
	if (unpickedCount == cnt) return 1;
	return 0;
}


int getPickedIdx() {
	int i = 1;
	for (; i <= n; i++) {
		if (isPicked[i] == 1) {
			break;
		}
	}
	if (i == n + 1) return 0;
	return i;
}

int getUnpickedIdx() {
	int i = 1;
	for (; i <= n; i++) {
		if (!isPicked[i]) {
			break;
		}
	}
	if (i == n + 1) return 0;
	return i;
}

int calculatePopulationDiff() {
	int aPopulation = 0, bPopulation = 0;

	for (int i = 1; i <= n; i++) {
		if (isPicked[i]) aPopulation += population[i];
		else bPopulation += population[i];
	}
	return abs(aPopulation - bPopulation);
}

void combination(int cnt, int next, int k) {
	if (cnt == k) {
		int pickedIdx = getPickedIdx();
		int unpickedIdx = getUnpickedIdx();
		if (pickedIdx && unpickedIdx && checkPickedConnection(pickedIdx) && checkUnpickedConnection(unpickedIdx)) {
			int diff = calculatePopulationDiff();
			if (diff < minimum) {
				minimum = diff;
			}
			trueNum++;
		}
	}
	for (int i = next; i <= n; i++) {
		isPicked[i] = true;
		combination(cnt + 1, i + 1, k);
		isPicked[i] = false;
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> n;
	init();
	for (int i = 0; i < n; i++) {
		cin >> population[i + 1];
	}
	for (int i = 1; i <= n; i++) {
		int t;
		cin >> t;
		for (int j = 0; j < t; j++) {
			int u;
			cin >> u;
			area[i].push_back(u);
			area[u].push_back(i);
		}
	}
	for (int r = 0; r <= n; r++) {
		combination(0, 1, r);
	}
	if (minimum == INT_MAX) minimum = -1;
	cout << minimum << "\n";
	return 0;
}

```
