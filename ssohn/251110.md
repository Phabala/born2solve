**닉네임**: ssohn

**문제 플랫폼**: 백준

**문제 이름 또는 번호**: 24416 / 알고리즘 수업 - 피보나치 수 1

**문제 링크**: https://www.acmicpc.net/problem/24416

**오늘의 메모(선택)**: Dynamic Programming이란 큰 문제를 작은 부분 문제로 나누고, 그 결과를 저장해서 재사용하는 방법을 의미한다.
DP를 쓸 수 있는 조건으로는 최적 부분 구조와 중복되는 부분 문제가 있다. 그리고 DP의 두 가지 접근법으로 하향식 구조와 상향식 구조가 있다. 하향식은 메모리제이션으로 재귀 + 메모리에 저장하는 방식이며 타뷸레이션은 작은 문제부터 차례로 계산하는 방법이다.

참고 :

**코드(선택)**:

```c++
#include <iostream>
#include <vector>

using namespace std;

int count1 = 0;
int count2 = 0;

int fib(int N) {
	if (N == 1 || N == 2) {
		count1++;
		return 1;
	}
	return (fib(N - 1)+ fib(N - 2));
}

int fibonacci(int N) {
	vector<int> f(N + 1);
	f[1] = f[2] = 1;
	for (int i = 3; i <= N; i++) {
		f[i] = f[i - 1] + f[i - 2];
		count2++;
	}
	return f[N];
}

int main() {
	int N;

	cin >> N;
	fib(N);
	fibonacci(N);
	cout << count1 << ' ' << count2 << '\n';
	return (0);
}
```


